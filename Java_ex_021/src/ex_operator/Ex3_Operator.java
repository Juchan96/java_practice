package ex_operator;

public class Ex3_Operator {

public static void main(String[] args) {
		
		//비트연산자
		//논리연산자와 유사하지만 bit단위(2진수) 연산만 가능.
		int a = 10;// 2진수로   1010
		int b = 7; // 2진수로   0111
		int c = a & b;   
		// &가 하나임. 2진수 단위의 (and)역할, boolean 으로 넘어오는게아니라 정수로 넘어옴, 10진수 연산(x)
		/* 2진수로 변환시 두 값이 모두 1이면 1, 나머지는 0 
		     같은 자릿수(세로)가 1로 같을경우에만 1로 내려옴 즉 1010   (나머지는 0)
		                                       0111 
		                                   =   0010     ==> 10진수로 2출력
		 */
		System.out.println("논리곱(and):"+ c );
		
		
		c = a | b;
		//2진수로 변환시 두 값이 모두 0이면 0, 나머지는 1
		/* 1010
		   0111
	 =     1111  ==> 10진수로 15출력
		 */
		System.out.println("논리합(or):" + c);
		
		
		c = a^b;
		//2진수로 변환시 두 값이 같으면 0, 다르면 1
		/* 1010
		   0111
	=      1101  ==> 10진수로 13출력
		 */
		System.out.println("베타적or(xor):" + c);
		
		System.out.println("--------------------------------");
		
		//시프트 연산자
		//bit단위의 연산을 수행하며, 오른쪽 또는 왼쪽으로 이동시켜 값에 대한 변화를 준다.
		a = 12;
		b = 2;
		c = a >> b;
		// a의 2진수 형태를 오른쪽으로 2칸만큼 이동시킨거임
		/*  a = 1100
		          1100    앞에 두칸은 00으로 채워지고 뒤에 두칸은 짤림
		 ==>  즉 0011       
		 */
		System.out.println(">> :" + c);
		
		
		
		char ch = 'F';   //아스키 코드로 변환해서 F ==> 70   ==> 1000110 (2진수로 변환)
		c = ch >> 1;  // F를 2진수로 변환후 오른쪽으로 한칸 이동    ==> 0100011 ==> 35
		System.out.println("c의 값:"+ c);
		System.out.println("c의 아스키 코드 값:"+ (char)c);  
		//(char)를 붙여주면 c의값을 아스키 코드로 변환해서 출력
		
		
		
	
	
	}//main
	
	
}
